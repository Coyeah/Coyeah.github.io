{"componentChunkName":"component---src-templates-blog-post-js","path":"/genetic-algorithm-with-js/","result":{"data":{"site":{"siteMetadata":{"title":"Coyeah's Blog","siteUrl":"https://www.coyeah.top"}},"markdownRemark":{"id":"8b8e9b69-d199-5437-a555-1ed33212dac4","excerpt":"前言：有一次在知乎上看到一篇文章，介绍遗传算法的，并且用遗传算法来训练一群像素小鸟，优化出一只通关相当厉害的像素鸟。又一次在知乎上看到一篇文章，用 JavaScript 来做一个遗传算法的小 Demo，就是本文要介绍的小 Demo…","html":"<p>前言：有一次在知乎上看到一篇文章，介绍遗传算法的，并且用遗传算法来训练一群像素小鸟，优化出一只通关相当厉害的像素鸟。又一次在知乎上看到一篇文章，用 JavaScript 来做一个遗传算法的小 Demo，就是本文要介绍的小 Demo，学习那位大兄弟的代码出来的给自己练个手，实在抱歉没能搜回那个大兄弟的项目地址，就没有 post 出来了。</p>\n<h2>遗传算法</h2>\n<blockquote>\n<p>遗传算法（Genetic Algorithm）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p>\n</blockquote>\n<p>初高中生物教过我们，基因是产生一条多肽链或功能 RNA 所需的全部核苷酸序列，带有遗传讯息的 DNA 片段称为基因。通过不同的基因组合，构建出不同的个体。而我们的目的，就是在一个种群里面，通过繁衍，即基因的不断组合最终获取到我们要的目标各地，就像我们要的是一只能够通一百关的像素小鸟。而在繁衍的过程中，要充分体现出随机性和优胜劣汰的遗传规则，所以与目标个体越相近的，则有着更大的机会被保留并生产出下一代，而在生产出下一代的过程中，还有参杂基因突变的可能性。</p>\n<p>简单来说就是从模仿染色体的结构不断地递归式组合,最后形成一个目标个体。</p>\n<h2>动手写 Demo</h2>\n<p>我们的目的是初始化一堆字符串，然后通过遗传算法，最终得到我们想要的字符串内容，<strong>You are more powerful than any other person.</strong></p>\n<p>该 Demo 中通过对字符串随机生成一个初始种群，然后组合形成新的种群，再进行组合…直至出现目标个体，或者超过预设的繁衍次数，毕竟总不可能让他不断地递归下去吧，因为有可能运气不好还真的不出现目标个体。</p>\n<p>一开始我看到这个的时候，我以为是以字符为单位，后来看到大兄弟的代码，其实更甚者是用 <strong>0</strong> 与 <strong>1</strong> 来作为基础单位。妙啊~</p>\n<p>Github 项目<a href=\"https://github.com/Coyeah/genea\">传送门</a>，如果喜欢，给我一个 Star。</p>\n<h2>第一步：初始化种群</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">initPopulation</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentGeneration <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>populations <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>populationSize<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> gene <span class=\"token operator\">=</span> <span class=\"token function\">getRandomGene</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>geneLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 生成随机的基因组合，以 0 和 1 为单位，每个字母对应的是一个串二进制数字。</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>populations<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>gene<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// 把生成好的个体放入种群数组当中</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">makeFitnesses</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                            <span class=\"token comment\">// 计算一次种群当中每个个体的健康度（个体中与目标个体相同的基因数量 / 个体长度）</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>第二步：繁衍</h2>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">populationBreed</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">judge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>                        <span class=\"token comment\">// 判断是否种群当中是否出现了目标个体，或者繁衍次数已经超过预设的值</span>\n <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentGeneration<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">let</span> oldPopulations <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>populations<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">let</span> newPopulations <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len <span class=\"token operator\">=</span> oldPopulations<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">let</span> father <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// 在种群当中随机挑取一个父亲，当然不是完全随机的，这里要体现优胜劣汰。我们在第三部的时候探究一下。</span>\n   <span class=\"token keyword\">let</span> mother <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// 在种群当中随机挑取一个母亲</span>\n   <span class=\"token keyword\">let</span> child <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">crossOver</span><span class=\"token punctuation\">(</span>father<span class=\"token punctuation\">,</span> mother<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 根据父母的基因组合成新的个体，这个很好理解，就是一般一般嘛</span>\n   child <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">mutate</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\">// 变异，在孩子的基因中随机一个位置取反，即 0 > 1 或 1 > 0</span>\n   newPopulations<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>populations <span class=\"token operator\">=</span> newPopulations<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">makeFitnesses</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">populationBreed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// 重复步骤，就是不断的繁衍</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>第三步：随机又优胜劣汰下选择父母</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">rotate</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> pos <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> soFar <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>fitnesses<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> fitness <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>fitnesses<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    soFar <span class=\"token operator\">+=</span> fitness<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>soFar <span class=\"token operator\">/</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>totalFitness <span class=\"token operator\">>=</span> pos<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>populations<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>阅读下源码体会一下各种奥妙，我觉得这一块很值得回味。</p>\n<p>随意一个数值 <code class=\"language-text\">pos</code> 和定义一个为 0 的变量 <code class=\"language-text\">soFar</code>，种群里面顺序遍历，会把个体的健康度加入 <code class=\"language-text\">soFar</code> 中，如果超过 <code class=\"language-text\">pos</code>，那就决定是你了！</p>\n<p>妙就妙在这，如果你健康度高，其实很容易就会超过这个随机值，当然也有运气不好的时候，前面健康度高的给后面健康度低的做了嫁妆。所以体现了优胜劣汰，又饱含随机性的一段代码。</p>\n<h2>图解</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/eabd7ebb55603b1184720285552d34f3/14007/flow.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.9367088607595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3akUAAD/xAAXEAADAQAAAAAAAAAAAAAAAAAQIEEh/9oACAEBAAEFAqLq/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAaEAABBQEAAAAAAAAAAAAAAAARAAEQIGEh/9oACAEBAAE/ITqRlPxX/9oADAMBAAIAAwAAABDTzzz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAaEAACAwEBAAAAAAAAAAAAAAABEQAQMSFh/9oACAEBAAE/ECq4gLo6ANEEgH5BkQbXb//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Demo 过程图解\"\n        title=\"Demo 过程图解\"\n        src=\"/static/eabd7ebb55603b1184720285552d34f3/14007/flow.jpg\"\n        srcset=\"/static/eabd7ebb55603b1184720285552d34f3/ff44c/flow.jpg 158w,\n/static/eabd7ebb55603b1184720285552d34f3/a6688/flow.jpg 315w,\n/static/eabd7ebb55603b1184720285552d34f3/14007/flow.jpg 582w\"\n        sizes=\"(max-width: 582px) 100vw, 582px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","frontmatter":{"title":"用JavaScript做遗传算法的小Demo","date":"March 29, 2019","description":null}},"previous":{"fields":{"slug":"/front-end-performance-monitoring/"},"frontmatter":{"title":"前端性能监控Performance"}},"next":{"fields":{"slug":"/about-decorator/"},"frontmatter":{"title":"关于修饰器Decorator"}}},"pageContext":{"id":"8b8e9b69-d199-5437-a555-1ed33212dac4","previousPostId":"08358634-b861-5a80-9baf-db5fa49ae407","nextPostId":"72a9c424-0af5-5e47-bea6-affeed552e49"}},"staticQueryHashes":["2841359383","3274528899","4152100472"]}