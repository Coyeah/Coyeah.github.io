{"componentChunkName":"component---src-templates-blog-post-js","path":"/object-oriented-develop/","result":{"data":{"site":{"siteMetadata":{"title":"Coyeah's Blog","siteUrl":"https://www.coyeah.top"}},"markdownRemark":{"id":"b5b3debd-ace7-54ee-ac5d-4f14d895b125","excerpt":"…","html":"<p>模拟餐厅经营。</p>\n<h2>需求</h2>\n<blockquote>\n<p>我们现在要开一个餐厅啦，餐厅里面有服务员，有厨师，有顾客。学习面向对象，为餐厅和几个角色创建自己的类吧。\n餐厅可以招聘或者解雇职员，职员越多，就越能够满足更多的顾客需求，从而赚取更多的钱\n餐厅里的容量是有限的，当顾客坐满了，其他顾客需要排队\n服务员的工作有两个职责，一个是负责点菜，另外一个是上菜\n厨师的职责就一个，烹饪食物\n顾客可以做两件事情，一个是点菜，一个是吃</p>\n</blockquote>\n<p>这一系列写了很久。主要使用到的设计模式是职责链模式和观察者模式。</p>\n<p>工厂模式、命令模式、适配器模式、桥接模式这样的都会穿插在其中，可能是平时用习惯了，所以没有刻意是哪种设计模式。</p>\n<p>要有复盘的好习惯，这个模拟还会有些可视化的地方需要改进和添加，所以还在继续更新。</p>\n<p><a href=\"https://github.com/Coyeah/js-primer#oop-restaurant\">Github中的项目与知识点</a></p>\n<h2>职责链模式</h2>\n<p>这个模式给我最大的体会是，它更像一个中转站，用于数据处理的。用<code class=\"language-text\">switch</code>与<code class=\"language-text\">type</code>来判断是哪一种的信息，作出哪一种处理。</p>\n<p>职责链模式可以比喻成有序火车，而火车站里面有个函数充当时序表，但是不知道火车什么时候到，却知道该去哪。不好的是容易绕，得不断顺着走，绕出个逻辑来才行。</p>\n<p>开始 >> 中转站 >> 方法A >> 中转站 >> 中转站 >> … >> 方法B >> 中转站 >> 方法C >> 结束</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> <span class=\"token string\">'A'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do Something</span>\n    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">case</span> <span class=\"token string\">'B'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do Something</span>\n    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">case</span> <span class=\"token string\">'C'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do Something</span>\n    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">case</span> <span class=\"token string\">'D'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do Something</span>\n    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>观察者模式</h2>\n<p>观察者模式实现不难，但是逻辑很精密，拍手惊叹。</p>\n<p>以模拟餐厅作为例子。顾客、服务员、厨师相互之间进行解耦。</p>\n<p>顾客有很多，服务员和厨师也可以有很多。就会有一个类似于”管理者”的角色，可以是Object或者Array。初始化的时候就发起监听。当需要服务员或者厨师的时候，就发布来响应监听。而这个”管理者”的角色起到的作用就是找到空闲人员再分配任务。因为当发布消息的时候，是会让所有监听者都会接收到消息。如果不以”管理者”的形式监听，而以职员单体的形式监听。例如当一个顾客需要服务员的时候，所有服务员都会响应，这就有点糟糕了。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> Observer <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> _messages <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 注册信息接口</span>\n    <span class=\"token function-variable function\">regist</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span> fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// do Something</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 发布信息接口</span>\n    <span class=\"token function-variable function\">fire</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span> args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// do Something</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 移除信息接口</span>\n    <span class=\"token function-variable function\">remove</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span> fn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// do Something</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"title":"浅析面向对象开发","date":"June 28, 2018","description":null}},"previous":{"fields":{"slug":"/css-layout-holy-grail-and-flex/"},"frontmatter":{"title":"CSS布局：圣杯与flex"}},"next":{"fields":{"slug":"/shallow-copy-and-deep-copy-in-js/"},"frontmatter":{"title":"JavaScript中的浅拷贝与深拷贝"}}},"pageContext":{"id":"b5b3debd-ace7-54ee-ac5d-4f14d895b125","previousPostId":"1f72d5e4-b972-5868-993f-807b05d78ad1","nextPostId":"294895cc-2c3b-5a92-98ee-15c6c67b8a8f"}},"staticQueryHashes":["2841359383","3274528899","4152100472"]}