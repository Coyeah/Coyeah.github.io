{"componentChunkName":"component---src-templates-blog-post-js","path":"/bundleless-exploration-record/","result":{"data":{"site":{"siteMetadata":{"title":"Coyeah's Blog","siteUrl":"https://www.coyeah.top"}},"markdownRemark":{"id":"3db06860-b651-5150-ac2c-58335de606c6","excerpt":"探索的过程中写下的一个 demo。传送门。 第一次看到  这个单词是从一篇博文上，随后知道了 。关键词：不打包的构建工具、替代 webpack、ESM、vite… 搜索  网上有很多关于 snowpack 各种优势劣势的相关博文，以及与 webpack 的对比；谈及 snowpack…","html":"<p>探索的过程中写下的一个 demo。<a href=\"https://github.com/Coyeah/snowpack-demo\">传送门</a>。</p>\n<p>第一次看到 <code class=\"language-text\">bundleless</code> 这个单词是从一篇博文上，随后知道了 <code class=\"language-text\">snowpack</code>。关键词：<strong>不打包的构建工具</strong>、<strong>替代 webpack</strong>、<strong>ESM</strong>、<strong>vite</strong>…</p>\n<p>搜索 <code class=\"language-text\">snowpack</code> 网上有很多关于 snowpack 各种优势劣势的相关博文，以及与 webpack 的对比；谈及 snowpack 的优势，快；首先是<strong>冷启动快</strong>。因为不需要过多的打包，所以只需要处理修改后的单个文件，构建速度的优化，毋庸置疑的快。</p>\n<h2>一些原理</h2>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>module<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/_dist_/index.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>原理基于浏览器原生支持 ESM（ECMAScript modules），把原本在 webpack 上完成的工作交付给浏览器完成。：基本主流的浏览器版本都支持直接使用 ESM 了。</p>\n<h3>node_modules</h3>\n<p>snowpack 把所有从 node<em>modules 中引用的文件都分别打包至 `web</em>modules<code class=\"language-text\">文件夹中，以供 import；对于源码对直接引用</code>node<em>modules<code class=\"language-text\">的模块都做了路径的替换，换成了</code>/web</em>modules/<code class=\"language-text\">并返回回去。即</code>import React from ‘react’<code class=\"language-text\">转变为</code>import React from ‘/web_modules/react’`；</p>\n<p>默认情况下它将尝试安装 package.json 中 “dependencies” 列出的所有的依赖模块，如果模块定义了 ESM 格式的入口文件（即 package.json 有 “module” 字段），则会解析出其最小化的依赖关系，并将它和所依赖的模块都分别打包成一个单独的、浏览器环境能够原生支持的 ESM JS 文件，统一整理到 web_modules 文件夹中。</p>\n<h3>CSS 与 CSS Modules</h3>\n<p>经过处理后会生成 <code class=\"language-text\">index.css.proxy.js</code>，内容则是通过 createEleme 向 head 插入 style；</p>\n<p>snowpack 中启用 CSS Module 必须要以 <code class=\"language-text\">.module.css</code> 结尾，只有这样才会将文件特殊处理；</p>\n<h3>静态资源处理</h3>\n<p>同样处理成 <code class=\"language-text\">logo.svg.proxy.js</code>，导出的是静态资源的实际文件路径。</p>\n<h2>一些总结</h2>\n<p>一开始接触，是新奇；从而会去思考打包的必要性，打包工具主要解决了模块化和合并请求两个痛点；而在 HTTP/2 普及与 5G 时代的到来，把一部分内容分散请求变得可以接受了，而模块化浏览器则提供了支持；再者打包工具的越来越复杂，此消彼长自然难免不去思考。</p>\n<p>snowpack 的优点：</p>\n<ul>\n<li>全量构建快，增量构建也快。不需要打包，减少 CPU 消耗和等待时间，提升开发体验；</li>\n<li>源码对于打包工具的依赖比较低，在 webpack 的项目，可能会因使用 import 语法导入各种非 JS 资源和依赖 plugin 处理代码导致比较难替换了；</li>\n<li>依赖模块和源码间相互独立，相当于直接做了 code spliting，可以高效利用缓存来提高性能，项目重新发布时也不用让用户重新获取整个包。</li>\n</ul>\n<p>终归是有缺点的：</p>\n<ul>\n<li>把传统的 bundle 文件拆分成一堆小文件，多请求难免受制于浏览器 HTTP 请求并发和并行的瓶颈；</li>\n<li>没有生态，相关的工具链很缺；</li>\n<li>当前还有很多 npm 模块并没有提供 ESM 格式的导出文件，这也是最致命的。</li>\n</ul>\n<p>因此 snowpack 主要的应对场景是开发环境（热更新速度很快），官方也提供了 <code class=\"language-text\">@snowpack/plugin-webpack</code> 插件工具来应对生产模式，但是在学习过程中，尝试代 webpack-dev-server，但还是存在很多坑等不稳定因素，比较难满足业务场景。</p>\n<p>是一个很棒的学习机会，整体思路是非常棒的，也是对未来的一次认知，相信未来会用得上。在早期源码不多的情况下，能学到更贴近作者原始想法的东西，也算是很不错的收获。</p>\n<blockquote>\n<p>In 2019, you should use a bundler because you want to, not because you need to.</p>\n</blockquote>\n<h2>一些坑位</h2>\n<h3>package.json</h3>\n<p>需要去掉 <code class=\"language-text\">homepage</code> 字段。否则在执行 <code class=\"language-text\">snowpack build</code> 的时候会失败；使用 <code class=\"language-text\">@snowpack/plugin-webpack</code> 时，会获取 homepage 作为 baseUrl 使用，但是 npm 创建的 package 时 homepage 指向的是项目 readme。或者在 <code class=\"language-text\">snowpack.config.js</code> 中修改配置， <code class=\"language-text\">buildOptions: { baseUrl: &#39;/&#39;  }</code> 即可。</p>\n<h3>lodash-es</h3>\n<p><code class=\"language-text\">The Lodash library exported as ES modules.</code></p>\n<p>在 snowpack 构建的项目中，我们常常会这样使用：<code class=\"language-text\">import { isString } from &#39;lodash&#39;;</code>。但是如果所用到的项目不是通过 ES modules 导出的，就能使用这种解构的使用方式；</p>\n<p>再直接导致的问题，就是打包的包过大，不能做到按需加载；</p>\n<h3>关于 babel</h3>\n<p>在原有项目中，会加很多插件来支持<strong>箭头函数</strong>、<strong>async/await</strong>、<strong>Classes</strong>等等的ES2015+特性，而在 snowpack 中，因为应用原理，每个支持<code class=\"language-text\">&lt;script type=&quot;module&quot;&gt;</code>的浏览器都可以直接使用，也不需要额外打包一个 polyfill 文件；</p>\n<p>同样如果使用 <code class=\"language-text\">@snowpack/plugin-webpack</code> ，<code class=\"language-text\">bundle: true</code> 的时候，还是需要配置一些 babel 来优化，但是插件本身就会支持一些 runtime 的处理；</p>\n<h2>参考文档</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/149351900\">替代 webpack？带你了解 snowpack 原理，你还学得动么</a></li>\n<li><a href=\"https://developer.aliyun.com/article/768060\">Webpack 打包太慢？来试试 Bundleless 吧！</a></li>\n<li><a href=\"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/\">ES modules: A cartoon deep-dive</a></li>\n<li><a href=\"https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm\">What are CJS, AMD, UMD, and ESM in Javascript?</a></li>\n<li><a href=\"https://zhoukekestar.github.io/notes/2020/06/08/micro-frontends.html\">面向未来的中后台场景’伪’微前端几点想法</a></li>\n</ul>","frontmatter":{"title":"bundleless一次探索记录","date":"July 29, 2020","description":null}},"previous":{"fields":{"slug":"/antd-form-learning-record/"},"frontmatter":{"title":"antd探秘之Form篇"}},"next":{"fields":{"slug":"/browser-caching-mechanism/"},"frontmatter":{"title":"浏览器缓存机制回炉小记"}}},"pageContext":{"id":"3db06860-b651-5150-ac2c-58335de606c6","previousPostId":"28c90299-042b-59db-bafa-5bb56179def2","nextPostId":"99803592-7f8c-512d-8c66-82171f1756bf"}},"staticQueryHashes":["2841359383","3274528899","4152100472"]}