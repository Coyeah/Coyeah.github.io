{"componentChunkName":"component---src-templates-blog-post-js","path":"/ponder-react-hooks/","result":{"data":{"site":{"siteMetadata":{"title":"Coyeah's Blog","siteUrl":"https://www.coyeah.top"}},"markdownRemark":{"id":"19f0a08f-778c-5624-afd4-be098f5270f7","excerpt":"推出了  的新功能。抱着多学习多种树的心里来琢磨琢磨 hooks。什么是 hooks？是针对函数组件的特殊功能，解决的问题是状态共享。那如果 hooks 玩得好是不是没 redux 什么事了？ 函数组件区别 class 组件 从代码上看出区别： 除了写法上的区别以外，就是函数组件缺少了对于 React…","html":"<p><code class=\"language-text\">React v16.8</code> 推出了 <code class=\"language-text\">hooks</code> 的新功能。抱着多学习多种树的心里来琢磨琢磨 hooks。什么是 hooks？是针对函数组件的特殊功能，解决的问题是状态共享。那如果 hooks 玩得好是不是没 redux 什么事了？</p>\n<h2>函数组件区别 class 组件</h2>\n<p>从代码上看出区别：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// class 组件</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ExampleClass</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n  \n  <span class=\"token function\">componentWilllUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n  \n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 函数组件</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ExampleFunc</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>除了写法上的区别以外，就是函数组件缺少了对于 React 生命周期上的控制，所以函数组件通常用作展示组件，不会给他赋予一些业务逻辑的操作。hooks 的出现，函数组件可以有自己的内置状态和控制生命周期的能力，那 class 组件也好像没它什么事了？</p>\n<p>使用 React Hooks 相比于从前的类组件有以下几点好处：</p>\n<ul>\n<li>代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护。</li>\n<li>组件树层级变浅，在原本的代码中，我们经常使用 HOC/render props 等方式来复用组件的状态，增强功能等，无疑增加了组件树层数及渲染，而在 React Hooks 中，这些功能都可以通过强大的自定义的 Hooks 来实现。</li>\n</ul>\n<p>函数组件迫使你思考最佳实践。这是最重要的一点。组件的主要职责是 UI 渲染，理想情况下，所有的组件都是展示性组件，每个页面都是由这些展示性组件组合而成。</p>\n<p>更多介绍可以看看<em>参考资料</em></p>\n<ul>\n<li><a href=\"https://reactjs.org/docs/hooks-intro.html\">官网介绍</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/50597236\">一篇看懂 React Hooks</a></li>\n<li><a href=\"https://github.com/dt-fe/weekly/blob/master/95.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20VS%20Class%20%E7%BB%84%E4%BB%B6%E3%80%8B.md\">精读《Function VS Class 组件》</a></li>\n</ul>\n<h2>在学习过程中对部分 hooks 功能的自我理解</h2>\n<p>先抛出 <a href=\"https://github.com/Coyeah/react-primer#Hooks---demo14\">github 上的 demo</a>。</p>\n<h3>useCallback</h3>\n<p>从前写代码的时候并不以为然。组件中的 props 变化导致组件触发重新渲染。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>Component onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre></div>\n<p>解决办法：</p>\n<ul>\n<li>抽离变量，用变量复制，props 的指向不变。</li>\n<li>通过 this 存储函数，属于 class 组件的用法。</li>\n<li>useCallback</li>\n</ul>\n<p>通过 useCallback 获取一个<code class=\"language-text\">记忆体函数</code>，避免重新定义带来的不必要的重渲染。</p>\n<p>何为记忆体函数？由于函数组件本质就是函数，每一次调用就是一次函数的运行，而运行函数，这个函数作用域内的所有变量都重新定义，新的函数新的作用域新的定义变量，重新定义变量，props 的指向就变了，就违背了解决不必要渲染的目的。而记忆体函数就是让这个变量在函数运行的时候不要重新定义，变量指向不变，就解决问题了。</p>\n<h4>useCallback 与 useMemo</h4>\n<p><code class=\"language-text\">useCallback</code>所得的是一个记忆体函数，而<code class=\"language-text\">useMemo</code>所获取的是一个结果，即 return 的内容。</p>\n<h3>useRef</h3>\n<blockquote>\n<p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素</p>\n</blockquote>\n<p>函数组件中也是没有办法操控 ref 的，通过 useRef 返回的值传递 <code class=\"language-text\">组件/DOM</code> 的 ref 属性又完美解决问题。<em>可通过 <code class=\"language-text\">ref.current</code> 访问 DOM 节点</em>，<em>useRef 创建的是一个引用</em>。</p>\n<p>利用 useRef 规避了 capture value 特性。</p>\n<p><em>capture value</em>: 在我们使用 setTimeout 的时候，当中所有获取的值都是捕获当时的值，而并非最新值。也就是说，当按下一个按钮调用了 setTimeout 的时候（假设延迟 10 秒运行），而这期间对 state 的值无论怎么改变，都不会影响 setTimeout 的函数。<a href=\"https://segmentfault.com/a/1190000018685253\">参考资料：理解 React Hooks 的 Capture Value 特性</a></p>\n<h3>useLayoutEffect 与 useEffect</h3>\n<p>无论 useLayoutEffect 还是 useEffect 都是对应 ComponentDidMount、ComponentDidUpdate 以及 ComponentWillUnmount 的生命周期，在组件 render 后触发副作用。而其区别在于执行时机不同，useLayoutEffect 是在浏览器读取 DOM 事件时开始运行，在计算一个组件高宽并展示时可以得到更快的响应。而 useEffect 则需要 render 完全完成才开始运行。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">useEffect<span class=\"token operator\">:</span>                         start <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span> end\n                    读取 <span class=\"token constant\">DOM</span> <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">></span> 渲染至页面 <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">></span> render\nuseLayoutEffect<span class=\"token operator\">:</span>      start <span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span> end</code></pre></div>\n<p><a href=\"https://github.com/dt-fe/weekly/issues/138\">参考资料：精读《useEffect 完全指南》</a></p>\n<h3>useImperativeHandle 与 forwardRef</h3>\n<p>官方代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">FancyInput</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> ref</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> inputRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">useImperativeHandle</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">focus</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      inputRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">focus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>input ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>inputRef<span class=\"token punctuation\">}</span> <span class=\"token operator\">...</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nFancyInput <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>FancyInput<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>useImperativeHandle 与 forwardRef 是结合使用的，通俗来讲，效果其实就是让父组件通过 ref 来操纵 子组件中的节点，并且可以规定了父组件能够控制的方法。</p>\n<p>useImperativeHandle 第一个参数指向父组件传入的 ref，第二个参数（函数）返回一个对象，创建出给父组件开放的 ref 方法。</p>\n<p>而 forwardRef 则是让子组件可以获取传下来的 ref。<code class=\"language-text\">function Comonent (props, ref) { ... }</code></p>\n<h2>小结</h2>\n<p>呃嗯~~没想好该结啥子结论，继续学习。</p>","frontmatter":{"title":"琢磨 react hooks","date":"June 18, 2019","description":null}},"previous":{"fields":{"slug":"/redux-store-design-optimization/"},"frontmatter":{"title":"redux store 设计优化问题"}},"next":{"fields":{"slug":"/rxjs-learning-record/"},"frontmatter":{"title":"挤牙膏之旅——RxJS记录"}}},"pageContext":{"id":"19f0a08f-778c-5624-afd4-be098f5270f7","previousPostId":"7bd4c793-b89e-56e7-850e-a57c9788a634","nextPostId":"e2250dfd-68df-52b1-9c5a-bb5c3f79096b"}},"staticQueryHashes":["2841359383","3274528899","4152100472"]}