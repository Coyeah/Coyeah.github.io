{"componentChunkName":"component---src-templates-blog-post-js","path":"/docker-develop-env-construction/","result":{"data":{"site":{"siteMetadata":{"title":"Coyeah's Blog","siteUrl":"https://www.coyeah.top"}},"markdownRemark":{"id":"6b677b0a-eb84-56f0-8692-9f38386ec863","excerpt":"Docker desktop 在电脑里吃了好几个月的灰，一直也没下手把玩，恰巧有个机会迫使自己开始用 docker 搭建起服务器和数据库了。涉及 Eggjs 和 mysql 的基础项目搭建。留个笔记。docker gitbook Eggjs 部署 要部署上 docker…","html":"<p>Docker desktop 在电脑里吃了好几个月的灰，一直也没下手把玩，恰巧有个机会迫使自己开始用 docker 搭建起服务器和数据库了。涉及 Eggjs 和 mysql 的基础项目搭建。留个笔记。<a href=\"https://yeasy.gitbooks.io/docker_practice/content/\">docker gitbook</a></p>\n<h2>Eggjs 部署</h2>\n<p>要部署上 docker，首先在项目中新建一个 <code class=\"language-text\">Dockerfile</code> 的文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># 拉取要创建的新镜像的 base image（基础镜像），类似于面向对象里边的基础类</span>\n<span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>8.11.3<span class=\"token punctuation\">-</span>alpine\n\n<span class=\"token comment\"># 设置时区</span>\n<span class=\"token keyword\">ENV</span> TIME_ZONE=Asia/Shanghai\n\n<span class=\"token comment\"># 在容器内运行命令</span>\n<span class=\"token keyword\">RUN</span> \\\n  mkdir <span class=\"token punctuation\">-</span>p /usr/src/app \\\n  &amp;&amp; apk add <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>no<span class=\"token punctuation\">-</span>cache tzdata \\\n  &amp;&amp; echo <span class=\"token string\">\"${TIME_ZONE}\"</span> <span class=\"token punctuation\">></span> /etc/timezone \\ \n  &amp;&amp; ln <span class=\"token punctuation\">-</span>sf /usr/share/zoneinfo/$<span class=\"token punctuation\">{</span>TIME_ZONE<span class=\"token punctuation\">}</span> /etc/localtime \n\n<span class=\"token comment\"># 创建 docker 工作目录</span>\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token comment\"># 拷贝，把本机当前目录下的 package.json 拷贝到 Image 的 /usr/src/app/ 文件夹下</span>\n<span class=\"token keyword\">COPY</span> package.json /usr/src/app/\n\n<span class=\"token comment\"># 使用 npm 安装 app 所需要的所有依赖</span>\n<span class=\"token comment\"># RUN npm i</span>\n\n<span class=\"token keyword\">RUN</span> npm i <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>registry=https<span class=\"token punctuation\">:</span>//registry.npm.taobao.org\n\n<span class=\"token comment\"># 拷贝本地的所有文件到路径中去</span>\n<span class=\"token keyword\">COPY</span> . /usr/src/app\n\n<span class=\"token comment\"># 暴露端口。如果程序是一个服务器，会监听一个或多个端口，可以用 EXPOSE 来表示这个端口</span>\n<span class=\"token keyword\">EXPOSE</span> 7001\n\n<span class=\"token comment\"># 给容器指定一个执行入口</span>\n<span class=\"token keyword\">CMD</span> npm run start</code></pre></div>\n<p>Dockerfile 的指令详解 》<a href=\"https://www.runoob.com/docker/docker-dockerfile.html\">传送门</a>，还有最佳实践，<a href=\"https://www.jianshu.com/p/cbce69c7a52f\">传送门</a>。</p>\n<p>通过命令执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker build -t myegg <span class=\"token builtin class-name\">.</span>\ndocker run -itd -p <span class=\"token number\">7001</span>:7001 --name myegg myegg</code></pre></div>\n<p>命令中有个 <code class=\"language-text\">.</code>，是上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p>\n<ul>\n<li><strong>-t</strong>：在容器指定一个伪终端或者终端；</li>\n<li><strong>-i</strong>：进行命令交互；</li>\n<li><strong>-p</strong>：匹配镜像内的网络端口号，即我们可以通过宿主机中访问5000端口来达到访问容器8080端口的目的；</li>\n</ul>\n<p>docker 命令大全 》<a href=\"https://www.runoob.com/docker/docker-command-manual.html\">传送门</a>，还有一些教程，<a href=\"https://blog.csdn.net/qq_32447301/article/details/79387649\">Docker删除容器与镜像</a>、<a href=\"https://segmentfault.com/a/1190000017151019\">MacOS Docker安装及使用</a>。</p>\n<h3>注意事项</h3>\n<p><a href=\"https://eggjs.org/zh-cn/core/deployment.html\">官方文档</a> 中介绍了应用部署的使用，有两点需要排雷。</p>\n<ul>\n<li>因为我们的 Docker 已经是后台运行了，在部署的时候需要去掉 <code class=\"language-text\">--daemon</code>，不能运行在后台的后台，会被 docker 机制关闭掉容器</li>\n<li>我们需要加上 <code class=\"language-text\">--port=7001</code>，因为 Docker 里有环境变量 PORT，如果不加上，会默认使用 Docker 里的环境变量，这个变量 PORT 是随机生成的数字，所以在正式部署的时候就会开启这个随机数生成的端口，从而报错。</li>\n</ul>\n<p>以上修改都是在 package.json 文件中</p>\n<h2>还有一些用到的</h2>\n<p>进入一个正在运行的 Docker 容器命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token function\">ps</span>\ndocker <span class=\"token builtin class-name\">exec</span> -it myegg /bin/sh</code></pre></div>\n<p>Docker 查看容器IP地址：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker inspect myegg</code></pre></div>\n<p>Networks > bridge > IPAddress</p>\n<h3>参考资料：</h3>\n<ul>\n<li><a href=\"https://hanhan.pro/deploy-eggjs-app-with-docker/\">使用Docker部署Egg.js应用及Docker常用命令</a></li>\n</ul>\n<h2>MySQL 部署</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 第一步，从 Docker 仓库中下载 MySQL 的官方镜像。我用的版本是 `8.0.19`。</span>\ndocker pull mysql:8.0.19\n<span class=\"token comment\"># 第二步，运行一个容器。</span>\ndocker run --name mysql8019 -e <span class=\"token assign-left variable\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span><span class=\"token number\">123456</span> -itd -p <span class=\"token number\">53306</span>:3306 --restart<span class=\"token operator\">=</span>always mysql:8.0.19\n<span class=\"token comment\"># docker mysql 就已经搭建好了。通过命令就可以从宿主机进入这个数据库</span>\nmysql -h <span class=\"token number\">127.0</span>.0.1 -P <span class=\"token number\">53306</span> -u root -p</code></pre></div>\n<p>这里有个问题就是发现一直没办法通过 <code class=\"language-text\">Sequel Pro</code> 来连接 docker mysql。报错如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string\">'caching_sha2_password'</span> cannot be loaded<span class=\"token operator\">:</span> <span class=\"token function\">dlopen</span><span class=\"token punctuation\">(</span><span class=\"token operator\">/</span>usr<span class=\"token operator\">/</span>local<span class=\"token operator\">/</span>mysql<span class=\"token operator\">/</span>lib<span class=\"token operator\">/</span>plugin<span class=\"token operator\">/</span>caching_sha2_password<span class=\"token punctuation\">.</span>so<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> image not found</code></pre></div>\n<p>这个不仅仅是在连接 docker mysql 中会出现的问题，即便本地安装的 mysql 也会有这样的问题。因为 MySql8.0 版本 和 5.0 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。此问题有两种方法，一种是更新 Navicat 驱动来解决此问题，另一种是将 MySQL 用户登录的加密规则修改为 mysql<em>native</em>password，第一种方法我试过了没有起作用，我这里采用第二种方法。</p>\n<p>在进入 mysql 中操作如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 修改root 可以通过任何客户端连接</span>\nALTER <span class=\"token environment constant\">USER</span> <span class=\"token string\">'root'</span>@<span class=\"token string\">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class=\"token string\">'123456'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\"># 刷新权限信息</span>\nflush privileges<span class=\"token punctuation\">;</span></code></pre></div>\n<h2>容器间互联</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 创建一个网络 my-net</span>\ndocker network create my-net\n<span class=\"token comment\"># 创建 docker 容器的时候就指定桥接网络，以 mysql 与 eggjs 举例</span>\ndocker run --name mysql8019 -e <span class=\"token assign-left variable\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span><span class=\"token number\">123456</span> -itd -p <span class=\"token number\">53306</span>:3306 --restart<span class=\"token operator\">=</span>always --network my-net mysql:8.0.19\ndocker run -itd -p <span class=\"token number\">7001</span>:7001 --name myegg --network my-net myegg</code></pre></div>\n<p>Done！通过容器名称即可 ping 通在同一网桥的容器。也可以直接 ping 其IP。</p>\n<h2>关于 Docker</h2>\n<p>Docker 是一个可以用来快速部署的<strong>轻量级虚拟技术</strong>，允许开发人员将自己的程序和运行环境一起打包，省去了每次都安装各种依赖和环境的麻烦。</p>\n<h3>镜像（Image）</h3>\n<p>操作系统分为内核和用户空间。</p>\n<p>对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker Image，就相当于是一个 root 文件系统。</p>\n<p>除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p>\n<h3>容器（Container）</h3>\n<p>Image 和 Container 的关系，就像是面向对象程序设计中的<code class=\"language-text\">类</code>和<code class=\"language-text\">实例</code>一样，镜像是静态的定义，容器是镜像运行时的实体。</p>\n<h3>仓库（Docker Registry）</h3>\n<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>\n<h3>Docker 架构</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/64aa6db994b66e2717a4930a3d6c80eb/bb33f/docker_architecture_1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABw0lEQVQoz3WSy27TUBRF+zEMmfFFiF9A6ogBDyFmTBmWUUGhlYooUoVpm0QBTOwmleu0dpw6idOkeT8cP+rGXihuXJo+jrR1z73ae+lI564ARFEEV03cR2EYX/3hiIl1xsA4ZVyzGJlVvOGIuftyFs7tcR+fC8ZK0sQgliuYukzbPbzuIJZ73mPm+sumxRAJYwnYss5pazXsSot+q4tRK1NtVOj1qwyGNUbjGmO7w7ak8TGrsprKkRK1OB8uwNfAMAzplxvURYUzsURVKaHpWXQtx+HBNxRF4Fj9gWlKPF1L8+TNBo9fbvDu+8HDwIFmYYlHtAsGTc1gXy3yKSuRVzMUJZm08Jejksrz9V2effjKoxcp3m7LDwCjCKczZGK2mNY7jLodNgsKrz8LpItZ5JxCRjAolTT2jutsyhXWxTKy2f6/g9sT3iw/cNiSC7zfypDX8xR+n7AvWBhGhduVZO8AE83X7Xo2qXyRV1/S/DkRaeq76MoeTUthFl19m7lmSea+Ld8sz58i6RLCYR7t9BfD5k96jR36XfXOhPd+myAIsG0bx3HwPC/W7GIKlw7BhYvn+dfvvu/jum7snUwmcTYB/gPlO+tG8Bks0QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Docker 架构图 1\"\n        title=\"Docker 架构图 1\"\n        src=\"/static/64aa6db994b66e2717a4930a3d6c80eb/f058b/docker_architecture_1.png\"\n        srcset=\"/static/64aa6db994b66e2717a4930a3d6c80eb/c26ae/docker_architecture_1.png 158w,\n/static/64aa6db994b66e2717a4930a3d6c80eb/6bdcf/docker_architecture_1.png 315w,\n/static/64aa6db994b66e2717a4930a3d6c80eb/f058b/docker_architecture_1.png 630w,\n/static/64aa6db994b66e2717a4930a3d6c80eb/40601/docker_architecture_1.png 945w,\n/static/64aa6db994b66e2717a4930a3d6c80eb/78612/docker_architecture_1.png 1260w,\n/static/64aa6db994b66e2717a4930a3d6c80eb/bb33f/docker_architecture_1.png 2208w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>宿主机上主要是运行 <code class=\"language-text\">Docker Daemon</code> 的核心程序，也就是负责做各种各样的操作。客户端通过命令 Daemon 来做实际的操作。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2086940bd33b76574ee8213e5cff90af/c88ae/docker_architecture_2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.632911392405056%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABN0lEQVQoz5WR207CQBRF+f+f0Ud5NRp5MQhG0d4szIAU6ExvUynSLkORcFXCTiZncs7Omn0yDX5VVRWHdzOZoWyP8N1Gez7a9VkY86d/pcZuY1U3Z6UizchDxZeOyJUmn85YFsVJ76buAcuyPDKUVUk+mzJP4m2isroMuGtcGoPTbBK02xzqImC9clGglEL6PkMhiJOYyUTxOQ5RStfzwwAngNsEaZoyGo0Qoo8QAikH3DR7XF338DxJlqVHSRt7jQqK7xwnaDFUb2ilsJwP7ruCVtfDdewaZFl9pBySZdn/wFVvsZzTnz4TRD5xFOEPJI89yVPPx7EtXl4FnY5gIM4ANyvvSmtNt9tBigGTYFyv/tCS3N4FeJ7AmPQ8cD1cg40xuK5LGCqSJCVJEqIoqh+K4/jkp/wA8XUGJeqry4YAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Docker 架构图 2\"\n        title=\"Docker 架构图 2\"\n        src=\"/static/2086940bd33b76574ee8213e5cff90af/f058b/docker_architecture_2.png\"\n        srcset=\"/static/2086940bd33b76574ee8213e5cff90af/c26ae/docker_architecture_2.png 158w,\n/static/2086940bd33b76574ee8213e5cff90af/6bdcf/docker_architecture_2.png 315w,\n/static/2086940bd33b76574ee8213e5cff90af/f058b/docker_architecture_2.png 630w,\n/static/2086940bd33b76574ee8213e5cff90af/40601/docker_architecture_2.png 945w,\n/static/2086940bd33b76574ee8213e5cff90af/78612/docker_architecture_2.png 1260w,\n/static/2086940bd33b76574ee8213e5cff90af/c88ae/docker_architecture_2.png 1541w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>","frontmatter":{"title":"Docker搭建环境爬坑计","date":"March 19, 2020","description":null}},"previous":{"fields":{"slug":"/2019-annual-summary/"},"frontmatter":{"title":"2019年终总结"}},"next":{"fields":{"slug":"/antd-form-learning-record/"},"frontmatter":{"title":"antd探秘之Form篇"}}},"pageContext":{"id":"6b677b0a-eb84-56f0-8692-9f38386ec863","previousPostId":"21415dfa-f448-5dc1-b313-df9554118646","nextPostId":"28c90299-042b-59db-bafa-5bb56179def2"}},"staticQueryHashes":["2841359383","3274528899","4152100472"]}